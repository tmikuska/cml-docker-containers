name: Release

permissions:
  contents: write

on:
  workflow_run:
    workflows: ["build.yml"]
    types: ["completed"]
  workflow_dispatch:
    inputs:
      build_run_id:
        description: 'Optional Run ID of the build that produced artifacts (artifact name is deb-artifacts-<run_id>)'
        required: false
        default: ''
      use_latest:
        description: 'If true and no build_run_id provided, use latest successful build'
        required: false
        default: 'false'
      release_tag:
        description: 'Optional release tag to use when creating a release'
        required: false
        default: ''
      release_name:
        description: 'Optional release name'
        required: false
        default: ''

jobs:
  release:
    name: Sign artifacts and create GitHub Release
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout (for helper scripts)
        uses: actions/checkout@v4

      - name: Determine build run and download artifacts
        id: fetch_artifacts
        run: |
          set -euo pipefail
          mkdir -p artifacts

          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            # Use the triggering build run id
            RUN_ID=${{ github.event.workflow_run.id }}
            echo "Triggered by workflow_run; using run id ${RUN_ID}"
          else
            if [ -n "${{ inputs.build_run_id }}" ]; then
              RUN_ID=${{ inputs.build_run_id }}
              echo "Manual dispatch, using provided build_run_id=${RUN_ID}"
            elif [ "${{ inputs.use_latest }}" = "true" ]; then
              echo "Manual dispatch: locating latest successful build run id via gh"
              # find latest successful run for build.yml
              RUN_ID=$(gh api repos/${GITHUB_REPOSITORY}/actions/workflows/build.yml/runs --jq '.workflow_runs | map(select(.conclusion=="success")) | .[0].id')
              echo "Found latest successful run id: ${RUN_ID}"
            else
              echo "No build_run_id provided and use_latest=false; aborting"
              exit 1
            fi
          fi

          echo "RUN_ID=${RUN_ID}" >> $GITHUB_ENV
          ARTIFACT_NAME=deb-artifacts-${RUN_ID}
          echo "ARTIFACT_NAME=${ARTIFACT_NAME}" >> $GITHUB_ENV

          # download the artifact
          echo "Downloading artifact ${ARTIFACT_NAME}"
          gh api repos/${GITHUB_REPOSITORY}/actions/artifacts --jq ".artifacts | map(select(.name==\"${ARTIFACT_NAME}\")) | .[0].archive_download_url" | xargs -I{} curl -L -o artifact.zip -H "Authorization: token ${GITHUB_TOKEN}" {} || true
          if [ -f artifact.zip ]; then
            unzip -q artifact.zip -d artifacts || true
            rm -f artifact.zip || true
          else
            echo "Artifact ${ARTIFACT_NAME} not found via API; attempting download-action fallback"
            # fallback to download-action if possible
            echo "deb-artifacts-${RUN_ID}" > /tmp/artifact_name
          fi

      - name: List downloaded artifacts
        run: |
          echo "Artifacts in ./artifacts:"
          ls -la artifacts || true

      - name: "Guard: ensure build was tag-triggered (auto path)"
        run: |
          set -euo pipefail
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            if [ ! -f artifacts/build-metadata.json ]; then
              echo "No build-metadata.json found; skipping release."
              exit 0
            fi
            if ! command -v jq >/dev/null 2>&1; then
              echo "jq not found - installing"
              sudo apt-get update
              sudo apt-get install -y jq
            fi
            REF=$(jq -r '.ref // empty' artifacts/build-metadata.json || true)
            echo "Build metadata ref=${REF}"
            case "$REF" in
              refs/tags/*) echo "Build was triggered by tag ${REF#refs/tags/}" ;;
              *) echo "Build was not triggered by a tag; skipping release."; exit 0 ;;
            esac
          else
            echo "Manual run; continuing"
          fi

      - name: Import GPG key
        id: import_gpg
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          passphrase: ${{ secrets.GPG_PASSPHRASE }}

      - name: Install signing tools and ensure gh CLI
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends gnupg2 curl devscripts || true
          if ! command -v gh >/dev/null 2>&1; then
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            sudo chmod 644 /usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
            sudo apt-get update
            sudo apt-get install -y gh
          else
            gh --version
          fi

      - name: Create detached ASCII signatures for artifacts
        env:
          GPG_FPR: ${{ steps.import_gpg.outputs.fingerprint }}
          PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          set -euo pipefail
          cd artifacts
          export GNUPGHOME="${GNUPGHOME:-$HOME/.gnupg}"
          chmod 700 "$GNUPGHOME" || true

          for f in *.deb *.changes *.buildinfo docker-refplat-images-*.tar.gz; do
            [ -f "$f" ] || continue
            echo "Signing $f -> ${f}.asc"
            gpg --batch --yes --pinentry-mode loopback \
                --passphrase "${PASSPHRASE}" \
                --local-user "${GPG_FPR}" \
                --armor --output "${f}.asc" --detach-sign "$f"
          done

      - name: (Optional) Debian-style sign .changes with debsign
        if: always()
        env:
          GPG_FPR: ${{ steps.import_gpg.outputs.fingerprint }}
        run: |
          set -euo pipefail
          cd artifacts
          if command -v debsign >/dev/null 2>&1; then
            for ch in *.changes; do
              [ -f "$ch" ] || continue
              echo "Attempting debsign on $ch (debian-style signature)"
              debsign -k"${GPG_FPR}" "$ch" || echo "debsign failed for $ch; skipping debsign"
            done
          else
            echo "debsign not installed; skipping Debian-native signing"
          fi

      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          cd artifacts

          # determine tag to use
          if [ -n "${{ inputs.release_tag }}" ]; then
            tag="${{ inputs.release_tag }}"
          else
            tag="build-${{ inputs.build_run_id }}"
          fi

          name="${{ inputs.release_name }}"
          [ -n "$name" ] || name="Automated release ${tag}"
          body="Automated release for build run ${{ inputs.build_run_id }}"

          echo "Creating release $tag"
          api_url="https://api.github.com/repos/${GITHUB_REPOSITORY}/releases"
          release_response=$(curl -s -X POST -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" \
            -d "$(printf '{"tag_name":"%s","name":"%s","body":"%s","draft":false,"prerelease":false}' "$tag" "$name" "$body")" "$api_url")
          upload_url=$(echo "$release_response" | python3 -c "import sys, json; d=json.load(sys.stdin); print(d.get('upload_url',''))")
          if [ -z "$upload_url" ]; then
            echo "Failed to create release: $release_response" >&2
            exit 1
          fi
          upload_url=${upload_url%\{*}

          # Create an ENV variable with upload_url and tag for subsequent steps
          echo "UPLOAD_URL=${upload_url}" >> $GITHUB_ENV
          echo "RELEASE_TAG=${tag}" >> $GITHUB_ENV

      - name: Upload individual artifacts via gh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          cd artifacts
          for f in *.deb *.changes *.buildinfo docker-refplat-images-*.tar.gz *.asc; do
            [ -f "$f" ] || continue
            echo "Uploading $f via gh release upload"
            gh release upload "${RELEASE_TAG}" "$f" || echo "upload failed for $f"
          done
